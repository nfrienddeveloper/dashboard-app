import "./chunk-N5DK5ZXR.js";
import {
  Fragment,
  Teleport,
  defineComponent,
  h
} from "./chunk-L4LVD3U4.js";
import {
  Calendar,
  CustomRenderingStore
} from "./chunk-FMYHF2SG.js";
import "./chunk-ROME4SDB.js";

// node_modules/@fullcalendar/vue3/dist/options.js
var OPTION_IS_COMPLEX = {
  headerToolbar: true,
  footerToolbar: true,
  events: true,
  eventSources: true,
  resources: true
};

// node_modules/@fullcalendar/vue3/dist/utils.js
function shallowCopy(val) {
  if (typeof val === "object") {
    if (Array.isArray(val)) {
      val = Array.prototype.slice.call(val);
    } else if (val) {
      val = { ...val };
    }
  }
  return val;
}

// node_modules/@fullcalendar/vue3/dist/FullCalendar.js
var FullCalendar = defineComponent({
  props: {
    options: Object
  },
  data() {
    return {
      renderId: 0,
      customRenderingMap: /* @__PURE__ */ new Map()
    };
  },
  methods: {
    getApi() {
      return getSecret(this).calendar;
    },
    buildOptions(suppliedOptions) {
      return {
        ...suppliedOptions,
        customRenderingMetaMap: this.$slots,
        handleCustomRendering: getSecret(this).handleCustomRendering
      };
    }
  },
  render() {
    const teleportNodes = [];
    for (const customRendering of this.customRenderingMap.values()) {
      teleportNodes.push(h(Teleport, {
        key: customRendering.id,
        to: customRendering.containerEl
      }, customRendering.generatorMeta(
        // a slot-render-function
        customRendering.renderProps
      )));
    }
    return h("div", {
      // when renderId is changed, Vue will trigger a real-DOM async rerender, calling beforeUpdate/updated
      attrs: { "data-fc-render-id": this.renderId }
    }, h(Fragment, teleportNodes));
  },
  mounted() {
    const customRenderingStore = new CustomRenderingStore();
    getSecret(this).handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);
    const calendarOptions = this.buildOptions(this.options);
    const calendar = new Calendar(this.$el, calendarOptions);
    getSecret(this).calendar = calendar;
    calendar.render();
    customRenderingStore.subscribe((customRenderingMap) => {
      this.customRenderingMap = customRenderingMap;
      this.renderId++;
      getSecret(this).needCustomRenderingResize = true;
    });
  },
  beforeUpdate() {
    this.getApi().resumeRendering();
  },
  updated() {
    if (getSecret(this).needCustomRenderingResize) {
      getSecret(this).needCustomRenderingResize = false;
      this.getApi().updateSize();
    }
  },
  beforeUnmount() {
    this.getApi().destroy();
  },
  watch: buildWatchers()
});
var FullCalendar_default = FullCalendar;
function getSecret(inst) {
  return inst;
}
function buildWatchers() {
  let watchers = {
    // watches changes of ALL options and their nested objects,
    // but this is only a means to be notified of top-level non-complex options changes.
    options: {
      deep: true,
      handler(options) {
        let calendar = this.getApi();
        calendar.pauseRendering();
        let calendarOptions = this.buildOptions(options);
        calendar.resetOptions(calendarOptions);
        this.renderId++;
      }
    }
  };
  for (let complexOptionName in OPTION_IS_COMPLEX) {
    watchers[`options.${complexOptionName}`] = {
      deep: true,
      handler(val) {
        if (val !== void 0) {
          let calendar = this.getApi();
          calendar.pauseRendering();
          calendar.resetOptions({
            // the only reason we shallow-copy is to trick FC into knowing there's a nested change.
            // TODO: future versions of FC will more gracefully handle event option-changes that are same-reference.
            [complexOptionName]: shallowCopy(val)
          }, true);
          this.renderId++;
        }
      }
    };
  }
  return watchers;
}

// node_modules/@fullcalendar/vue3/dist/index.js
var dist_default = FullCalendar_default;
export {
  dist_default as default
};
//# sourceMappingURL=@fullcalendar_vue3.js.map
