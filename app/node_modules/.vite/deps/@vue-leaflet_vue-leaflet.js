import "./chunk-N5DK5ZXR.js";
import {
  computed,
  h,
  inject,
  nextTick,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  render,
  watch
} from "./chunk-L4LVD3U4.js";
import "./chunk-ROME4SDB.js";

// node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js
var debounce = (fn, time) => {
  let timeout;
  return function(...args) {
    const context = this;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn.apply(context, args);
      timeout = null;
    }, time);
  };
};
var capitalizeFirstLetter = (string) => {
  if (!string || typeof string.charAt !== "function") {
    return string;
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
};
var propsBinder = (methods, leafletElement, props2) => {
  for (const key in props2) {
    const setMethodName = "set" + capitalizeFirstLetter(key);
    if (methods[setMethodName]) {
      watch(
        () => props2[key],
        (newVal, oldVal) => {
          methods[setMethodName](newVal, oldVal);
        }
      );
    } else if (leafletElement[setMethodName]) {
      watch(
        () => props2[key],
        (newVal) => {
          leafletElement[setMethodName](newVal);
        }
      );
    }
  }
};
var remapEvents = (contextAttrs) => {
  const result = {};
  for (const attrName in contextAttrs) {
    if (attrName.startsWith("on") && !attrName.startsWith("onUpdate") && attrName !== "onReady") {
      const eventName = attrName.slice(2).toLocaleLowerCase();
      result[eventName] = contextAttrs[attrName];
    }
  }
  return result;
};
var resetWebpackIcon = async (Icon) => {
  const modules = await Promise.all([
    import("/Users/nathanfriend/Desktop/Projects/dashboard-app/app/node_modules/leaflet/dist/images/marker-icon-2x.png"),
    import("/Users/nathanfriend/Desktop/Projects/dashboard-app/app/node_modules/leaflet/dist/images/marker-icon.png"),
    import("/Users/nathanfriend/Desktop/Projects/dashboard-app/app/node_modules/leaflet/dist/images/marker-shadow.png")
  ]);
  delete Icon.Default.prototype._getIconUrl;
  Icon.Default.mergeOptions({
    iconRetinaUrl: modules[0].default,
    iconUrl: modules[1].default,
    shadowUrl: modules[2].default
  });
};
var provideLeafletWrapper = (methodName) => {
  const wrapped = ref(
    () => console.warn(`Method ${methodName} has been invoked without being replaced`)
  );
  const wrapper = (...args) => wrapped.value(...args);
  wrapper.wrapped = wrapped;
  provide(methodName, wrapper);
  return wrapper;
};
var updateLeafletWrapper = (wrapper, leafletMethod) => wrapper.wrapped.value = leafletMethod;
var WINDOW_OR_GLOBAL = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || void 0;
var GLOBAL_LEAFLET_OPT = "useGlobalLeaflet";
var props = {
  options: {
    type: Object,
    default: () => ({})
  }
};
var setup = (props2) => {
  return { options: props2.options, methods: {} };
};
var props$1 = {
  ...props,
  pane: {
    type: String,
    default: "overlayPane"
  },
  attribution: {
    type: String,
    default: null
  },
  name: {
    type: String,
    custom: true,
    default: void 0
  },
  layerType: {
    type: String,
    custom: true,
    default: void 0
  },
  visible: {
    type: Boolean,
    custom: true,
    default: true
  }
};
var setup$1 = (props2, leafletRef, context) => {
  const addLayer = inject("addLayer");
  const removeLayer = inject("removeLayer");
  const {
    options: componentOptions,
    methods: componentMethods
  } = setup(props2);
  const options = {
    ...componentOptions,
    attribution: props2.attribution,
    pane: props2.pane
  };
  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });
  const removeThisLayer = () => removeLayer({ leafletObject: leafletRef.value });
  const methods = {
    ...componentMethods,
    setAttribution(val, old) {
      const attributionControl = this.$parent.leafletObject.attributionControl;
      attributionControl.removeAttribution(old).addAttribution(val);
    },
    setName() {
      removeThisLayer();
      if (props2.visible) {
        addThisLayer();
      }
    },
    setLayerType() {
      removeThisLayer();
      if (props2.visible) {
        addThisLayer();
      }
    },
    setVisible(isVisible) {
      if (leafletRef.value) {
        if (isVisible) {
          addThisLayer();
        } else {
          removeThisLayer();
        }
      }
    },
    bindPopup({ leafletObject }) {
      leafletRef.value.bindPopup(leafletObject);
    },
    bindTooltip({ leafletObject }) {
      leafletRef.value.bindTooltip(leafletObject);
    },
    unbindTooltip() {
      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;
      if (tooltip) {
        tooltip.unbindTooltip();
      }
    },
    unbindPopup() {
      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;
      if (popup) {
        popup.unbindPopup();
      }
    },
    updateVisibleProp(value) {
      context.emit("update:visible", value);
    }
  };
  provide("bindPopup", methods.bindPopup);
  provide("bindTooltip", methods.bindTooltip);
  provide("unbindTooltip", methods.unbindTooltip);
  provide("unbindPopup", methods.unbindPopup);
  onUnmounted(() => {
    methods.unbindPopup();
    methods.unbindTooltip();
    removeThisLayer();
  });
  return { options, methods };
};
var render2 = (ready, slots) => {
  if (ready && slots.default) {
    return h("div", { style: { display: "none" } }, slots.default());
  }
};
var props$2 = {
  ...props,
  interactive: {
    type: Boolean,
    default: true
  },
  bubblingMouseEvents: {
    type: Boolean,
    default: true
  }
};
var setup$2 = (props2) => {
  const { options: componentOptions, methods } = setup(props2);
  const options = {
    ...componentOptions,
    interactive: props2.interactive,
    bubblingMouseEvents: props2.bubblingMouseEvents
  };
  return { options, methods };
};
var props$3 = {
  ...props$1,
  ...props$2,
  stroke: {
    type: Boolean,
    custom: true,
    default: true
  },
  color: {
    type: String,
    custom: true,
    default: "#3388ff"
  },
  weight: {
    type: Number,
    custom: true,
    default: 3
  },
  opacity: {
    type: Number,
    custom: true,
    default: 1
  },
  lineCap: {
    type: String,
    custom: true,
    default: "round"
  },
  lineJoin: {
    type: String,
    custom: true,
    default: "round"
  },
  dashArray: {
    type: String,
    custom: true,
    default: null
  },
  dashOffset: {
    type: String,
    custom: true,
    default: null
  },
  fill: {
    type: Boolean,
    custom: true,
    default: false
  },
  fillColor: {
    type: String,
    custom: true,
    default: "#3388ff"
  },
  fillOpacity: {
    type: Number,
    custom: true,
    default: 0.2
  },
  fillRule: {
    type: String,
    custom: true,
    default: "evenodd"
  },
  className: {
    type: String,
    custom: true,
    default: null
  }
};
var setup$3 = (props2, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props2,
    leafletRef,
    context
  );
  const {
    options: interactiveLayerOptions,
    methods: interactiveLayerMethods
  } = setup$2(props2);
  const removeLayer = inject("removeLayer");
  const options = {
    ...layerOptions,
    ...interactiveLayerOptions,
    stroke: props2.stroke,
    color: props2.color,
    weight: props2.weight,
    opacity: props2.opacity,
    lineCap: props2.lineCap,
    lineJoin: props2.lineJoin,
    dashArray: props2.dashArray,
    dashOffset: props2.dashOffset,
    fill: props2.fill,
    fillColor: props2.fillColor,
    fillOpacity: props2.fillOpacity,
    fillRule: props2.fillRule,
    className: props2.className
  };
  const methods = {
    ...layerMethods,
    ...interactiveLayerMethods,
    setStroke(stroke) {
      leafletRef.value.setStyle({ stroke });
    },
    setColor(color) {
      leafletRef.value.setStyle({ color });
    },
    setWeight(weight) {
      leafletRef.value.setStyle({ weight });
    },
    setOpacity(opacity) {
      leafletRef.value.setStyle({ opacity });
    },
    setLineCap(lineCap) {
      leafletRef.value.setStyle({ lineCap });
    },
    setLineJoin(lineJoin) {
      leafletRef.value.setStyle({ lineJoin });
    },
    setDashArray(dashArray) {
      leafletRef.value.setStyle({ dashArray });
    },
    setDashOffset(dashOffset) {
      leafletRef.value.setStyle({ dashOffset });
    },
    setFill(fill) {
      leafletRef.value.setStyle({ fill });
    },
    setFillColor(fillColor) {
      leafletRef.value.setStyle({ fillColor });
    },
    setFillOpacity(fillOpacity) {
      leafletRef.value.setStyle({ fillOpacity });
    },
    setFillRule(fillRule) {
      leafletRef.value.setStyle({ fillRule });
    },
    setClassName(className) {
      leafletRef.value.setStyle({ className });
    }
  };
  onBeforeUnmount(() => {
    removeLayer({ leafletObject: leafletRef.value });
  });
  return { options, methods };
};
var props$4 = {
  ...props$3,
  latLng: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  /**
   * Radius of the marker in pixels.
   */
  radius: {
    type: Number,
    default: null
  }
};
var setup$4 = (props2, leafletRef, context) => {
  const { options: pathOptions, methods: pathMethods } = setup$3(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...pathOptions,
    ...props2
  };
  const methods = {
    ...pathMethods,
    setRadius(radius) {
      leafletRef.value.setRadius(radius);
    },
    setLatLng(latLng) {
      leafletRef.value.setLatLng(latLng);
    }
  };
  return { options, methods };
};
var props$5 = {
  ...props$4,
  /**
   * Radius of the circle in meters.
   */
  radius: {
    type: Number,
    default: null
  }
};
var setup$5 = (props2, leafletRef, context) => {
  const {
    options: circleMarkerOptions,
    methods: circleMarkerMethods
  } = setup$4(props2, leafletRef, context);
  const options = {
    ...circleMarkerOptions,
    ...props2
  };
  const methods = {
    ...circleMarkerMethods
  };
  return { options, methods };
};
var script = {
  name: "LCircle",
  props: props$5,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$5(props2, leafletRef, context);
    onMounted(async () => {
      const { circle, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = circle(props2.latLng, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script.__file = "src/components/LCircle.vue";
var script$1 = {
  name: "LCircleMarker",
  props: props$4,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$4(props2, leafletRef, context);
    onMounted(async () => {
      const { circleMarker, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = circleMarker(props2.latLng, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$1.__file = "src/components/LCircleMarker.vue";
var props$6 = {
  ...props,
  position: {
    type: String,
    default: "topright"
  }
};
var setup$6 = (props2, leafletRef) => {
  const {
    options: componentOptions,
    methods: componentMethods
  } = setup(props2);
  const options = {
    ...componentOptions,
    position: props2.position
  };
  const methods = {
    ...componentMethods,
    setPosition(position) {
      if (leafletRef.value) {
        leafletRef.value.setPosition(position);
      }
    }
  };
  onUnmounted(() => {
    if (leafletRef.value) {
      leafletRef.value.remove();
    }
  });
  return { options, methods };
};
var render$1 = (slots) => {
  if (slots.default) {
    return h("div", { ref: "root" }, slots.default());
  }
  return null;
};
var script$2 = {
  name: "LControl",
  props: {
    ...props$6,
    disableClickPropagation: {
      type: Boolean,
      custom: true,
      default: true
    },
    disableScrollPropagation: {
      type: Boolean,
      custom: true,
      default: false
    }
  },
  setup(props2, context) {
    const leafletRef = ref({});
    const root = ref(null);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const registerControl = inject("registerControl");
    const { options, methods } = setup$6(props2, leafletRef);
    onMounted(async () => {
      const { Control, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      const LControl = Control.extend({
        onAdd() {
          return root.value;
        }
      });
      leafletRef.value = new LControl(options);
      propsBinder(methods, leafletRef.value, props2);
      registerControl({ leafletObject: leafletRef.value });
      if (props2.disableClickPropagation) {
        DomEvent.disableClickPropagation(root.value);
      }
      if (props2.disableScrollPropagation) {
        DomEvent.disableScrollPropagation(root.value);
      }
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$1(this.$slots);
  }
};
script$2.__file = "src/components/LControl.vue";
var props$7 = {
  ...props$6,
  prefix: {
    type: String,
    default: "Vue-Leaflet",
    custom: true
  }
};
var setup$7 = (props2, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props2,
    leafletRef
  );
  const options = {
    ...controlOptions,
    prefix: props2.prefix
  };
  const methods = {
    ...controlMethods,
    setPrefix(prefix) {
      leafletRef.value.setPrefix(prefix);
    }
  };
  return { options, methods };
};
var script$3 = {
  name: "LControlAttribution",
  props: props$7,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const registerControl = inject("registerControl");
    const { options, methods } = setup$7(props2, leafletRef);
    onMounted(async () => {
      const { control } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = control.attribution(options);
      propsBinder(methods, leafletRef.value, props2);
      registerControl({ leafletObject: leafletRef.value });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  }
};
script$3.__file = "src/components/LControlAttribution.vue";
var props$8 = {
  ...props$6,
  collapsed: {
    type: Boolean,
    default: true
  },
  autoZIndex: {
    type: Boolean,
    default: true
  },
  hideSingleBase: {
    type: Boolean,
    default: false
  },
  sortLayers: {
    type: Boolean,
    default: false
  },
  sortFunction: {
    type: Function,
    default: void 0
  }
};
var setup$8 = (props2, leafletRef) => {
  const { options: controlOptions } = setup$6(props2, leafletRef);
  const options = {
    ...controlOptions,
    collapsed: props2.collapsed,
    autoZIndex: props2.autoZIndex,
    hideSingleBase: props2.hideSingleBase,
    sortLayers: props2.sortLayers,
    sortFunction: props2.sortFunction
  };
  const methods = {
    addLayer(layer) {
      if (layer.layerType === "base") {
        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);
      } else if (layer.layerType === "overlay") {
        leafletRef.value.addOverlay(layer.leafletObject, layer.name);
      }
    },
    removeLayer(layer) {
      leafletRef.value.removeLayer(layer.leafletObject);
    }
  };
  return { options, methods };
};
var script$4 = {
  name: "LControlLayers",
  props: props$8,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const registerLayerControl = inject("registerLayerControl");
    const { options, methods } = setup$8(props2, leafletRef);
    onMounted(async () => {
      const { control } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = control.layers(null, null, options);
      propsBinder(methods, leafletRef.value, props2);
      registerLayerControl({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  }
};
script$4.__file = "src/components/LControlLayers.vue";
var props$9 = {
  ...props$6,
  maxWidth: {
    type: Number,
    default: 100
  },
  metric: {
    type: Boolean,
    default: true
  },
  imperial: {
    type: Boolean,
    default: true
  },
  updateWhenIdle: {
    type: Boolean,
    default: false
  }
};
var setup$9 = (props2, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props2,
    leafletRef
  );
  const options = {
    ...controlOptions,
    maxWidth: props2.maxWidth,
    metric: props2.metric,
    imperial: props2.imperial,
    updateWhenIdle: props2.updateWhenIdle
  };
  return { options, methods: controlMethods };
};
var script$5 = {
  name: "LControlScale",
  props: props$9,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const registerControl = inject("registerControl");
    const { options, methods } = setup$9(props2, leafletRef);
    onMounted(async () => {
      const { control } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = control.scale(options);
      propsBinder(methods, leafletRef.value, props2);
      registerControl({ leafletObject: leafletRef.value });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  }
};
script$5.__file = "src/components/LControlScale.vue";
var props$a = {
  ...props$6,
  zoomInText: {
    type: String,
    default: "+"
  },
  zoomInTitle: {
    type: String,
    default: "Zoom in"
  },
  zoomOutText: {
    type: String,
    default: "-"
  },
  zoomOutTitle: {
    type: String,
    default: "Zoom out"
  }
};
var setup$a = (props2, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props2,
    leafletRef
  );
  const options = {
    ...controlOptions,
    zoomInText: props2.zoomInText,
    zoomInTitle: props2.zoomInTitle,
    zoomOutText: props2.zoomOutText,
    zoomOutTitle: props2.zoomOutTitle
  };
  return { options, methods: controlMethods };
};
var script$6 = {
  name: "LControlZoom",
  props: props$a,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const registerControl = inject("registerControl");
    const { options, methods } = setup$a(props2, leafletRef);
    onMounted(async () => {
      const { control } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = control.zoom(options);
      propsBinder(methods, leafletRef.value, props2);
      registerControl({ leafletObject: leafletRef.value });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  }
};
script$6.__file = "src/components/LControlZoom.vue";
var props$b = {
  ...props$1
};
var setup$b = (props2, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...layerOptions
  };
  const methods = {
    ...layerMethods,
    addLayer(layer) {
      leafletRef.value.addLayer(layer.leafletObject);
    },
    removeLayer(layer) {
      leafletRef.value.removeLayer(layer.leafletObject);
    }
  };
  provide("addLayer", methods.addLayer);
  provide("removeLayer", methods.removeLayer);
  return { options, methods };
};
var props$c = {
  ...props$b
};
var setup$c = (props2, leafletRef) => {
  const { options: layerOptions, methods: layerGroupMethods } = setup$b(
    props2,
    leafletRef
  );
  const options = {
    ...layerOptions,
    ...props2
  };
  const methods = {
    ...layerGroupMethods
  };
  return { options, methods };
};
var script$7 = {
  props: props$c,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { methods, options } = setup$c(props2, leafletRef);
    onMounted(async () => {
      const { featureGroup, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = featureGroup(options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$7.__file = "src/components/LFeatureGroup.vue";
var props$d = {
  ...props$b,
  geojson: {
    type: [Object, Array],
    default: () => ({})
  }
};
var setup$d = (props2, leafletRef) => {
  const { options: layerOptions, methods: layerGroupMethods } = setup$b(
    props2,
    leafletRef
  );
  const options = {
    ...layerOptions,
    ...props2
  };
  const methods = {
    ...layerGroupMethods,
    setGeojson(newVal) {
      leafletRef.value.clearLayers();
      leafletRef.value.addData(newVal);
    },
    getGeoJSONData() {
      return leafletRef.value.toGeoJSON();
    },
    getBounds() {
      return leafletRef.value.getBounds();
    }
  };
  return { options, methods };
};
var script$8 = {
  props: props$d,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { methods, options } = setup$d(props2, leafletRef);
    onMounted(async () => {
      const { geoJSON, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = geoJSON(props2.geojson, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$8.__file = "src/components/LGeoJson.vue";
var props$e = {
  ...props$1,
  pane: {
    type: String,
    default: "tilePane"
  },
  opacity: {
    type: Number,
    custom: false,
    default: 1
  },
  zIndex: {
    type: Number,
    default: 1
  },
  tileSize: {
    type: Number,
    default: 256
  },
  noWrap: {
    type: Boolean,
    default: false
  },
  minZoom: {
    type: Number,
    default: 0
  },
  maxZoom: {
    type: Number,
    default: void 0
  }
};
var setup$e = (props2, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...layerOptions,
    pane: props2.pane,
    opacity: props2.opacity,
    zIndex: props2.zIndex,
    tileSize: props2.tileSize,
    noWrap: props2.noWrap,
    minZoom: props2.minZoom,
    maxZoom: props2.maxZoom
  };
  return { options, methods: { ...layerMethods } };
};
var script$9 = {
  props: {
    ...props$e,
    childRender: {
      type: Function,
      required: true
    }
  },
  setup(props2, context) {
    const leafletRef = ref({});
    const tileComponents = ref({});
    const root = ref(null);
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$e(props2, leafletRef, context);
    onMounted(async () => {
      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      methods.onUnload = (e) => {
        const key = leafletRef.value._tileCoordsToKey(e.coords);
        if (tileComponents[key]) {
          tileComponents[key].innerHTML = "";
          tileComponents[key] = void 0;
        }
      };
      methods.setTileComponent = () => {
        leafletRef.value.redraw();
      };
      const GLayer = GridLayer.extend({
        createTile(coords) {
          const key = leafletRef.value._tileCoordsToKey(coords);
          tileComponents[key] = DomUtil.create("div");
          let vNode = h(
            { setup: props2.childRender, props: ["coords"] },
            { coords }
          );
          render(vNode, tileComponents[key]);
          return tileComponents[key];
        }
      });
      leafletRef.value = new GLayer(options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.on("tileunload", methods.onUnload);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    onUnmounted(() => {
      leafletRef.value.off("tileunload", methods.unLoad);
    });
    return { root, ready, leafletObject: leafletRef };
  },
  render() {
    if (this.ready) {
      return h("div", { style: { display: "none" }, ref: "root" });
    }
    return null;
  }
};
script$9.__file = "src/components/LGridLayer.vue";
var props$f = {
  iconUrl: {
    type: String,
    custom: true,
    default: null
  },
  iconRetinaUrl: {
    type: String,
    custom: true,
    default: null
  },
  iconSize: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  iconAnchor: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  popupAnchor: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0]
  },
  tooltipAnchor: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0]
  },
  shadowUrl: {
    type: String,
    custom: true,
    default: null
  },
  shadowRetinaUrl: {
    type: String,
    custom: true,
    default: null
  },
  shadowSize: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  shadowAnchor: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  bgPos: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0]
  },
  className: {
    type: String,
    custom: true,
    default: ""
  },
  options: {
    type: Object,
    custom: true,
    default: () => ({})
  }
};
var script$a = {
  name: "LIcon",
  props: {
    ...props$f,
    ...props
  },
  setup(props2, context) {
    const root = ref(null);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const canSetParentHtml = inject("canSetParentHtml");
    const setParentHtml = inject("setParentHtml");
    const setIcon = inject("setIcon");
    let onDomEvent;
    let offDomEvent;
    let divIcon;
    let icon;
    let iconObject = void 0;
    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {
      const elHtml = el && el.innerHTML;
      if (!recreationNeeded) {
        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {
          setParentHtml(elHtml);
        }
        return;
      }
      const listeners = remapEvents(context.attrs);
      if (iconObject) {
        offDomEvent(iconObject, listeners);
      }
      const { options: componentOptions } = setup(props2);
      const options = {
        ...componentOptions,
        iconUrl: props2.iconUrl,
        iconRetinaUrl: props2.iconRetinaUrl,
        iconSize: props2.iconSize,
        iconAnchor: props2.iconAnchor,
        popupAnchor: props2.popupAnchor,
        tooltipAnchor: props2.tooltipAnchor,
        shadowUrl: props2.shadowUrl,
        shadowRetinaUrl: props2.shadowRetinaUrl,
        shadowSize: props2.shadowSize,
        shadowAnchor: props2.shadowAnchor,
        bgPos: props2.bgPos,
        className: props2.className,
        html: elHtml || props2.html
      };
      iconObject = options.html ? divIcon(options) : icon(options);
      onDomEvent(iconObject, listeners);
      setIcon(iconObject);
    };
    const scheduleCreateIcon = () => {
      nextTick(() => createIcon(root.value, true, false));
    };
    const scheduleHtmlSwap = () => {
      nextTick(() => createIcon(root.value, false, true));
    };
    const methods = {
      setIconUrl: scheduleCreateIcon,
      setIconRetinaUrl: scheduleCreateIcon,
      setIconSize: scheduleCreateIcon,
      setIconAnchor: scheduleCreateIcon,
      setPopupAnchor: scheduleCreateIcon,
      setTooltipAnchor: scheduleCreateIcon,
      setShadowUrl: scheduleCreateIcon,
      setShadowRetinaUrl: scheduleCreateIcon,
      setShadowAnchor: scheduleCreateIcon,
      setBgPos: scheduleCreateIcon,
      setClassName: scheduleCreateIcon,
      setHtml: scheduleCreateIcon
    };
    onMounted(async () => {
      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      onDomEvent = DomEvent.on;
      offDomEvent = DomEvent.off;
      divIcon = lDivIcon;
      icon = lIcon;
      propsBinder(methods, {}, props2);
      const observer = new MutationObserver(scheduleHtmlSwap);
      observer.observe(root.value, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
      scheduleCreateIcon();
    });
    return { root };
  },
  render() {
    const content = this.$slots.default ? this.$slots.default() : void 0;
    return h("div", { ref: "root" }, content);
  }
};
script$a.__file = "src/components/LIcon.vue";
var props$g = {
  ...props$1,
  url: {
    type: String,
    required: true
  },
  bounds: {
    type: [Array, Object],
    required: true
  },
  opacity: {
    type: Number,
    custom: true,
    default: 1
  },
  alt: {
    type: String,
    default: ""
  },
  interactive: {
    type: Boolean,
    default: false
  },
  crossOrigin: {
    type: Boolean,
    default: false
  },
  errorOverlayUrl: {
    type: String,
    custom: true,
    default: ""
  },
  zIndex: {
    type: Number,
    custom: true,
    default: 1
  },
  className: {
    type: String,
    default: ""
  }
};
var setup$f = (setupProps, LeafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    setupProps,
    LeafletRef,
    context
  );
  const options = {
    ...layerOptions,
    ...setupProps
  };
  const methods = {
    ...layerMethods,
    /**
     * Sets the opacity of the overlay.
     * @param {number} opacity
     */
    setOpacity(opacity) {
      return LeafletRef.value.setOpacity(opacity);
    },
    /**
     * Changes the URL of the image.
     * @param {string} url
     */
    setUrl(url) {
      return LeafletRef.value.setUrl(url);
    },
    /**
     * Update the bounds that this ImageOverlay covers
     * @param {LatLngBounds | Array<Array<number>>} bounds
     */
    setBounds(bounds) {
      return LeafletRef.value.setBounds(bounds);
    },
    /**
     * Get the bounds that this ImageOverlay covers
     * @returns {LatLngBounds}
     */
    getBounds() {
      return LeafletRef.value.getBounds();
    },
    /**
     * Returns the instance of HTMLImageElement used by this overlay.
     * @returns {HTMLElement}
     */
    getElement() {
      return LeafletRef.value.getElement();
    },
    /**
     * Brings the layer to the top of all overlays.
     */
    bringToFront() {
      return LeafletRef.value.bringToFront();
    },
    /**
     * Brings the layer to the bottom of all overlays.
     */
    bringToBack() {
      return LeafletRef.value.bringToBack();
    },
    /**
     * Changes the zIndex of the image overlay.
     * @param {number} zIndex
     */
    setZIndex(zIndex) {
      return LeafletRef.value.setZIndex(zIndex);
    }
  };
  return { options, methods };
};
var script$b = {
  name: "LImageOverlay",
  props: props$g,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$f(props2, leafletRef, context);
    onMounted(async () => {
      const { imageOverlay, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = imageOverlay(props2.url, props2.bounds, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$b.__file = "src/components/LImageOverlay.vue";
var script$c = {
  props: props$b,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { methods } = setup$b(props2, leafletRef, context);
    onMounted(async () => {
      const { layerGroup, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = layerGroup(props2.options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$c.__file = "src/components/LLayerGroup.vue";
var script$d = {
  emits: ["ready", "update:zoom", "update:center", "update:bounds"],
  props: {
    ...props,
    /**
     * The center of the map, supports .sync modifier
     */
    center: {
      type: [Object, Array],
      default: () => [0, 0]
    },
    /**
     * The bounds of the map, supports .sync modifier
     */
    bounds: {
      type: [Array, Object],
      default: void 0
    },
    /**
     * The max bounds of the map
     */
    maxBounds: {
      type: [Array, Object],
      default: void 0
    },
    /**
     * The zoom of the map, supports .sync modifier
     */
    zoom: {
      type: Number,
      default: 0
    },
    /**
     * The minZoom of the map
     */
    minZoom: {
      type: Number,
      default: void 0
    },
    /**
     * The maxZoom of the map
     */
    maxZoom: {
      type: Number,
      default: void 0
    },
    /**
     * The paddingBottomRight of the map
     */
    paddingBottomRight: {
      type: Array,
      default: void 0
    },
    /**
     * The paddingTopLeft of the map
     */
    paddingTopLeft: {
      type: Array,
      default: void 0
    },
    /**
     * The padding of the map
     */
    padding: {
      type: Array,
      default: void 0
    },
    /**
     * The worldCopyJump option for the map
     */
    worldCopyJump: {
      type: Boolean,
      default: false
    },
    /**
     * The CRS to use for the map. Can be an object that defines a coordinate reference
     * system for projecting geographical points into screen coordinates and back
     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string
     * name identifying one of Leaflet's defined CRSs, such as "EPSG4326".
     */
    crs: {
      type: [String, Object],
      default: "EPSG3857"
    },
    maxBoundsViscosity: {
      type: Number,
      default: void 0
    },
    inertia: {
      type: Boolean,
      default: void 0
    },
    inertiaDeceleration: {
      type: Number,
      default: void 0
    },
    inertiaMaxSpeed: {
      type: Number,
      default: void 0
    },
    easeLinearity: {
      type: Number,
      default: void 0
    },
    zoomAnimation: {
      type: Boolean,
      default: void 0
    },
    zoomAnimationThreshold: {
      type: Number,
      default: void 0
    },
    fadeAnimation: {
      type: Boolean,
      default: void 0
    },
    markerZoomAnimation: {
      type: Boolean,
      default: void 0
    },
    noBlockingAnimations: {
      type: Boolean,
      default: false
    },
    useGlobalLeaflet: {
      type: Boolean,
      default: false
    }
  },
  setup(props2, context) {
    const root = ref(null);
    const blueprint = reactive({
      ready: false,
      leafletRef: {},
      layersToAdd: [],
      layersInControl: []
    });
    const { options: componentOptions } = setup(props2);
    const options = {
      ...componentOptions,
      minZoom: props2.minZoom,
      maxZoom: props2.maxZoom,
      maxBounds: props2.maxBounds,
      maxBoundsViscosity: props2.maxBoundsViscosity,
      worldCopyJump: props2.worldCopyJump,
      crs: props2.crs,
      center: props2.center,
      zoom: props2.zoom,
      inertia: props2.inertia,
      inertiaDeceleration: props2.inertiaDeceleration,
      inertiaMaxSpeed: props2.inertiaMaxSpeed,
      easeLinearity: props2.easeLinearity,
      zoomAnimation: props2.zoomAnimation,
      zoomAnimationThreshold: props2.zoomAnimationThreshold,
      fadeAnimation: props2.fadeAnimation,
      markerZoomAnimation: props2.markerZoomAnimation
    };
    const addLayer = provideLeafletWrapper("addLayer");
    const removeLayer = provideLeafletWrapper("removeLayer");
    const registerControl = provideLeafletWrapper("registerControl");
    const registerLayerControl = provideLeafletWrapper("registerLayerControl");
    provide(GLOBAL_LEAFLET_OPT, props2.useGlobalLeaflet);
    const eventHandlers = {
      moveEndHandler() {
        context.emit("update:zoom", blueprint.leafletRef.getZoom());
        context.emit("update:center", blueprint.leafletRef.getCenter());
        context.emit("update:bounds", blueprint.leafletRef.getBounds());
      },
      overlayAddHandler(e) {
        const layer = blueprint.layersInControl.find((l) => l.name === e.name);
        if (layer) {
          layer.updateVisibleProp(true);
        }
      },
      overlayRemoveHandler(e) {
        const layer = blueprint.layersInControl.find((l) => l.name === e.name);
        if (layer) {
          layer.updateVisibleProp(false);
        }
      }
    };
    onMounted(async () => {
      if (props2.useGlobalLeaflet) {
        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || await import("./leaflet.js");
      }
      const {
        map,
        CRS,
        Icon,
        latLngBounds,
        latLng,
        DomEvent
      } = props2.useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      try {
        options.beforeMapMount && await options.beforeMapMount();
      } catch (error) {
        console.error(
          `The following error occurred running the provided beforeMapMount hook ${error.message}`
        );
      }
      await resetWebpackIcon(Icon);
      const optionsCrs = typeof options.crs == "string" ? CRS[options.crs] : options.crs;
      options.crs = optionsCrs || CRS.EPSG3857;
      const methods = {
        addLayer(layer) {
          if (layer.layerType !== void 0) {
            if (blueprint.layerControl === void 0) {
              blueprint.layersToAdd.push(layer);
            } else {
              const exist = blueprint.layersInControl.find(
                (l) => l.leafletObject._leaflet_id === layer.leafletObject._leaflet_id
              );
              if (!exist) {
                blueprint.layerControl.addLayer(layer);
                blueprint.layersInControl.push(layer);
              }
            }
          }
          if (layer.visible !== false) {
            blueprint.leafletRef.addLayer(layer.leafletObject);
          }
        },
        removeLayer(layer) {
          if (layer.layerType !== void 0) {
            if (blueprint.layerControl === void 0) {
              blueprint.layersToAdd = blueprint.layersToAdd.filter(
                (l) => l.name !== layer.name
              );
            } else {
              blueprint.layerControl.removeLayer(layer.leafletObject);
              blueprint.layersInControl = blueprint.layersInControl.filter(
                (l) => l.leafletObject._leaflet_id !== layer.leafletObject._leaflet_id
              );
            }
          }
          blueprint.leafletRef.removeLayer(layer.leafletObject);
        },
        registerLayerControl(lControlLayer) {
          blueprint.layerControl = lControlLayer;
          blueprint.layersToAdd.forEach((layer) => {
            blueprint.layerControl.addLayer(layer);
          });
          blueprint.layersToAdd = [];
          registerControl(lControlLayer);
        },
        registerControl(lControl) {
          blueprint.leafletRef.addControl(lControl.leafletObject);
        },
        setZoom(newVal) {
          const zoom = blueprint.leafletRef.getZoom();
          if (newVal !== zoom) {
            blueprint.leafletRef.setZoom(newVal, {
              animate: props2.noBlockingAnimations ? false : null
            });
          }
        },
        setPaddingBottomRight(newVal) {
          blueprint.paddingBottomRight = newVal;
        },
        setPaddingTopLeft(newVal) {
          blueprint.paddingTopLeft = newVal;
        },
        setPadding(newVal) {
          blueprint.padding = newVal;
        },
        setCrs(newVal) {
          const prevBounds = blueprint.leafletRef.getBounds();
          blueprint.leafletRef.options.crs = newVal;
          blueprint.leafletRef.fitBounds(prevBounds, {
            animate: false,
            padding: [0, 0]
          });
        },
        fitBounds(bounds) {
          blueprint.leafletRef.fitBounds(bounds, {
            animate: this.noBlockingAnimations ? false : null
          });
        },
        setBounds(newVal) {
          if (!newVal) {
            return;
          }
          const newBounds = latLngBounds(newVal);
          if (!newBounds.isValid()) {
            return;
          }
          const oldBounds = blueprint.lastSetBounds || blueprint.leafletRef.getBounds();
          const boundsChanged = !oldBounds.equals(newBounds, 0);
          if (boundsChanged) {
            blueprint.lastSetBounds = newBounds;
            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);
          }
        },
        setCenter(newVal) {
          if (newVal == null) {
            return;
          }
          const newCenter = latLng(newVal);
          const oldCenter = blueprint.lastSetCenter || blueprint.leafletRef.getCenter();
          if (oldCenter.lat !== newCenter.lat || oldCenter.lng !== newCenter.lng) {
            blueprint.lastSetCenter = newCenter;
            blueprint.leafletRef.panTo(newCenter, {
              animate: this.noBlockingAnimations ? false : null
            });
          }
        }
      };
      updateLeafletWrapper(addLayer, methods.addLayer);
      updateLeafletWrapper(removeLayer, methods.removeLayer);
      updateLeafletWrapper(registerControl, methods.registerControl);
      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);
      blueprint.leafletRef = map(root.value, options);
      propsBinder(methods, blueprint.leafletRef, props2);
      const listeners = remapEvents(context.attrs);
      blueprint.leafletRef.on(
        "moveend",
        debounce(eventHandlers.moveEndHandler, 100)
      );
      blueprint.leafletRef.on("overlayadd", eventHandlers.overlayAddHandler);
      blueprint.leafletRef.on(
        "overlayremove",
        eventHandlers.overlayRemoveHandler
      );
      DomEvent.on(blueprint.leafletRef, listeners);
      blueprint.ready = true;
      nextTick(() => context.emit("ready", blueprint.leafletRef));
    });
    onBeforeUnmount(() => {
      if (blueprint.leafletRef) {
        blueprint.leafletRef.remove();
      }
    });
    const leafletObject = computed(() => blueprint.leafletRef);
    const ready = computed(() => blueprint.ready);
    return { root, ready, leafletObject };
  },
  render() {
    return h(
      "div",
      { style: { width: "100%", height: "100%" }, ref: "root" },
      this.ready ? this.$slots.default() : {}
    );
  }
};
script$d.__file = "src/components/LMap.vue";
var props$h = {
  ...props$1,
  pane: {
    type: String,
    default: "markerPane"
  },
  draggable: {
    type: Boolean,
    custom: true,
    default: false
  },
  latLng: {
    type: [Object, Array],
    custom: true,
    default: null
  },
  icon: {
    type: [Object],
    default: () => void 0,
    custom: false
  },
  zIndexOffset: {
    type: Number,
    custom: false,
    default: null
  }
};
var setup$g = (props2, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...layerOptions,
    ...props2
  };
  const methods = {
    ...layerMethods,
    setDraggable(value) {
      if (leafletRef.value.dragging) {
        value ? leafletRef.value.dragging.enable() : leafletRef.value.dragging.disable();
      }
    },
    latLngSync(event) {
      context.emit("update:latLng", event.latlng);
      context.emit("update:lat-lng", event.latlng);
    },
    setLatLng(newVal) {
      if (newVal == null) {
        return;
      }
      if (leafletRef.value) {
        const oldLatLng = leafletRef.value.getLatLng();
        if (!oldLatLng || !oldLatLng.equals(newVal)) {
          leafletRef.value.setLatLng(newVal);
        }
      }
    }
  };
  return { options, methods };
};
var script$e = {
  name: "LMarker",
  props: props$h,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    provide("canSetParentHtml", () => !!leafletRef.value.getElement());
    provide(
      "setParentHtml",
      (html) => leafletRef.value.getElement().innerHTML = html
    );
    provide(
      "setIcon",
      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)
    );
    const { options, methods } = setup$g(props2, leafletRef, context);
    if (options.icon === void 0) {
      delete options.icon;
    }
    onMounted(async () => {
      const { marker, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = marker(props2.latLng, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.on("move", debounce(methods.latLngSync, 100));
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$e.__file = "src/components/LMarker.vue";
var props$i = {
  ...props$3,
  latLngs: {
    type: Array,
    default: () => []
  },
  smoothFactor: {
    type: Number,
    custom: true,
    default: 1
  },
  noClip: {
    type: Boolean,
    custom: true,
    default: false
  }
};
var setup$h = (props2, leafletRef, context) => {
  const { options: pathOptions, methods: pathMethods } = setup$3(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...pathOptions,
    ...props2
  };
  const methods = {
    ...pathMethods,
    setSmoothFactor(smoothFactor) {
      leafletRef.value.setStyle({ smoothFactor });
    },
    setNoClip(noClip) {
      leafletRef.value.setStyle({ noClip });
    },
    addLatLng(latLng) {
      leafletRef.value.addLatLng(latLng);
    }
  };
  return { options, methods };
};
var props$j = {
  ...props$i
};
var setup$i = (props2, leafletRef, context) => {
  const { options: polylineOptions, methods: polylineMethods } = setup$h(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...polylineOptions,
    ...props2
  };
  const methods = {
    ...polylineMethods,
    toGeoJSON(precision) {
      return leafletRef.value.toGeoJSON(precision);
    }
  };
  return { options, methods };
};
var script$f = {
  name: "LPolygon",
  props: props$j,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$i(props2, leafletRef, context);
    onMounted(async () => {
      const { polygon, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = polygon(props2.latLngs, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$f.__file = "src/components/LPolygon.vue";
var script$g = {
  name: "LPolyline",
  props: props$i,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$h(props2, leafletRef, context);
    onMounted(async () => {
      const { polyline, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = polyline(props2.latLngs, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$g.__file = "src/components/LPolyline.vue";
var props$k = {
  ...props,
  content: {
    type: String,
    default: null
  }
};
var setup$j = (props2, leafletRef) => {
  const { options, methods: componentMethods } = setup(props2);
  const methods = {
    ...componentMethods,
    setContent(newVal) {
      if (leafletRef.value && newVal !== null && newVal !== void 0) {
        leafletRef.value.setContent(newVal);
      }
    }
  };
  return { options, methods };
};
var render$2 = (slots) => {
  if (slots.default) {
    return h("div", { ref: "root" }, slots.default());
  }
  return null;
};
var props$l = {
  ...props$k,
  latLng: {
    type: [Object, Array],
    default: () => []
  }
};
var setup$k = (props2, leafletRef) => {
  const { options, methods } = setup$j(props2, leafletRef);
  const unbindPopup = inject("unbindPopup");
  onBeforeUnmount(() => {
    unbindPopup();
  });
  return { options, methods };
};
var script$h = {
  name: "LPopup",
  props: props$l,
  setup(props2, context) {
    const leafletRef = ref({});
    const root = ref(null);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const bindPopup = inject("bindPopup");
    const { options, methods } = setup$k(props2, leafletRef);
    onMounted(async () => {
      const { popup, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = popup(options);
      if (props2.latLng !== void 0) {
        leafletRef.value.setLatLng(props2.latLng);
      }
      propsBinder(methods, leafletRef.value, props2);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.setContent(props2.content || root.value);
      bindPopup({ leafletObject: leafletRef.value });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$2(this.$slots);
  }
};
script$h.__file = "src/components/LPopup.vue";
var props$m = {
  ...props$j,
  bounds: {
    type: Array,
    default: void 0
  }
};
var setup$l = (props2, leafletRef, context) => {
  const { options: polygonOptions, methods: polygonMethods } = setup$i(
    props2,
    leafletRef,
    context
  );
  const options = {
    ...polygonOptions,
    ...props2
  };
  const methods = {
    ...polygonMethods,
    setBounds(latLngBounds) {
      leafletRef.value.setBounds(latLngBounds);
    },
    setLatLngs(latLngs) {
      leafletRef.value.setBounds(latLngs);
    }
  };
  return { options, methods };
};
var script$i = {
  name: "LRectangle",
  props: props$m,
  setup(props2, context) {
    const leafletRef = ref({});
    const ready = ref(false);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$l(props2, leafletRef, context);
    onMounted(async () => {
      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      const bounds = props2.bounds && props2.bounds.length ? latLngBounds(props2.bounds) : latLngBounds(props2.latLngs);
      leafletRef.value = rectangle(bounds, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      ready.value = true;
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render2(this.ready, this.$slots);
  }
};
script$i.__file = "src/components/LRectangle.vue";
var props$n = {
  ...props$e,
  tms: {
    type: Boolean,
    default: false
  },
  subdomains: {
    type: String,
    default: "abc"
  },
  detectRetina: {
    type: Boolean,
    default: false
  },
  url: {
    type: String,
    default: null
  }
};
var setup$m = (props2, leafletRef) => {
  const {
    options: gridLayerOptions,
    methods: gridLayerMethods
  } = setup$e(props2, leafletRef);
  const options = {
    ...gridLayerOptions,
    tms: props2.tms,
    subdomains: props2.subdomains,
    detectRetina: props2.detectRetina
  };
  return {
    options,
    methods: {
      ...gridLayerMethods
    }
  };
};
var script$j = {
  props: props$n,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$m(props2, leafletRef);
    onMounted(async () => {
      const { tileLayer, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = tileLayer(props2.url, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef };
  },
  render() {
    return null;
  }
};
script$j.__file = "src/components/LTileLayer.vue";
var props$o = {
  ...props$k
};
var setup$n = (props2, leafletRef) => {
  const { options, methods } = setup$j(props2, leafletRef);
  const unbindTooltip = inject("unbindTooltip");
  onBeforeUnmount(() => {
    unbindTooltip();
  });
  return { options, methods };
};
var script$k = {
  name: "LTooltip",
  props: props$o,
  setup(props2, context) {
    const leafletRef = ref({});
    const root = ref(null);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const bindTooltip = inject("bindTooltip");
    const { options, methods } = setup$n(props2, leafletRef);
    onMounted(async () => {
      const { tooltip, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = tooltip(options);
      propsBinder(methods, leafletRef.value, props2);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.setContent(props2.content || root.value);
      bindTooltip({ leafletObject: leafletRef.value });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$2(this.$slots);
  }
};
script$k.__file = "src/components/LTooltip.vue";
var props$p = {
  ...props$n,
  baseUrl: {
    type: String,
    default: null,
    required: true
  },
  layers: {
    type: String,
    default: ""
  },
  styles: {
    type: String,
    default: ""
  },
  format: {
    type: String,
    default: "image/jpeg"
  },
  transparent: {
    type: Boolean,
    custom: false
  },
  version: {
    type: String,
    default: "1.1.1"
  },
  crs: {
    default: null
  },
  upperCase: {
    type: Boolean,
    default: false
  }
};
var setup$o = (props2, leafletRef) => {
  const {
    options: tileLayerOptions,
    methods: tileLayerMethods
  } = setup$m(props2, leafletRef);
  const options = {
    ...tileLayerOptions,
    layers: props2.layers,
    styles: props2.styles,
    format: props2.format,
    transparent: props2.transparent,
    version: props2.version,
    crs: props2.crs,
    upperCase: props2.upperCase
  };
  return {
    options,
    methods: {
      ...tileLayerMethods
    }
  };
};
var script$l = {
  props: props$p,
  setup(props2, context) {
    const leafletRef = ref({});
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);
    const addLayer = inject("addLayer");
    const { options, methods } = setup$o(props2, leafletRef);
    onMounted(async () => {
      const { tileLayer, DomEvent } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import("./leaflet-src.esm-GWDUXBHD.js");
      leafletRef.value = tileLayer.wms(props2.baseUrl, options);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props2);
      addLayer({
        ...props2,
        ...methods,
        leafletObject: leafletRef.value
      });
      nextTick(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  }
};
script$l.__file = "src/components/LWmsTileLayer.vue";
export {
  script as LCircle,
  script$1 as LCircleMarker,
  script$2 as LControl,
  script$3 as LControlAttribution,
  script$4 as LControlLayers,
  script$5 as LControlScale,
  script$6 as LControlZoom,
  script$7 as LFeatureGroup,
  script$8 as LGeoJson,
  script$9 as LGridLayer,
  script$a as LIcon,
  script$b as LImageOverlay,
  script$c as LLayerGroup,
  script$d as LMap,
  script$e as LMarker,
  script$f as LPolygon,
  script$g as LPolyline,
  script$h as LPopup,
  script$i as LRectangle,
  script$j as LTileLayer,
  script$k as LTooltip,
  script$l as LWmsTileLayer
};
//# sourceMappingURL=@vue-leaflet_vue-leaflet.js.map
